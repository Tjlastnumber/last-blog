{
  "hash": "e3af5c3a260b475ff60441c28a5d0ff0",
  "result": {
    "engine": "jupyter",
    "markdown": "---\ntitle: docker swarm 部署 prometheus 监控\nauthor: lastnumber\ndate: 2024-04-08\ncategories:\n  - news\n  - monitoring\n  - prometheus\n  - docker swarm\nimage: docker_swarm.png\ndescription: 使用 prometheus 同时监控 docker swarm 集群的多个 stock\n---\n\n# docker swarm 使用 prometheus 监控集群状态\n\n由于不能从外部访问 docker swarm 的 overlay 网络，prometheus 无法在外部访问应用端口，所以需要将 prometheus 部署对应的 stack 环境并加入到 ingress 网络，这样就能在内部通过 vip 或者 service name 访问容器\n\n## 打开 docker 采集端口\n\n1. 修改 `/etc/docker/daemon.json` 添加配置：\n\n```json\n{\n  \"metrics-addr\": \"0.0.0.0:9323\"\n  \"experimental\": true\n}\n```\n\n也可以配置 ip 地址而不是 `0.0.0.0`\n\n2. 重启 docker 守护进程\n\n\n```{bash}\nsystemctl restart docker\n```\n\n\n<div class=\"callout-warning\"> \n- 需要集群中所有 docker 打开端口\n- 需要打开服务器防火墙\n<div>\n\n## 在 docker swarm 创建 configs\n\n```yaml\n# my global config\nglobal:\n  scrape_interval: 1m # Set the scrape interval to every 15 seconds. Default is every 1 minute.\n  evaluation_interval: 1m # Evaluate rules every 15 seconds. The default is every 1 minute.\n  scrape_timeout: 10s # scrape_timeout is set to the global default (10s).\n\n# Alertmanager configuration\nalerting:\n  alertmanagers:\n    - static_configs:\n        - targets:\n          # - alertmanager:9093\n          \nscrape_configs:\n  - job_name: \"dockerswarm\"\n    dockerswarm_sd_configs:\n      - host: unix:///var/run/docker.sock\n        role: nodes\n    relabel_configs:\n      - source_labels: [__meta_dockerswarm_node_address]\n        target_label: __address__\n        replacement: $1:9323\n      - source_labels: [__meta_dockerswarm_node_hostname]\n        target_label: instance\n\n  - job_name: 'dockertasks'\n    metrics_path: /actuator/prometheus\n    dockerswarm_sd_configs:\n      - host: unix:///var/run/docker.sock\n        role: tasks\n    relabel_configs:\n      # Only keep containers that should be running.\n      - source_labels: [__meta_dockerswarm_task_desired_state]\n        regex: running\n        action: keep\n      - source_labels: [__meta_dockerswarm_container_label_com_docker_stack_namespace]\n        regex: dev\n        action: keep\n      - source_labels: [__meta_dockerswarm_container_label_external_metrics_enable]\n        regex: true\n        action: keep\n      - source_labels: [__address__]\n        target_label: __address__\n        regex: '(.+):.*'\n        replacement: $1:8080\n      - source_labels: [__meta_dockerswarm_service_label_com_docker_stack_namespace]\n        target_label: namespace\n      - source_labels: [__meta_dockerswarm_service_name]\n        target_label: serviceName\n      - source_labels: [__meta_dockerswarm_service_name]\n        target_label: application\n      - source_labels: [__meta_dockerswarm_task_id]\n        target_label: instance\n```\n\n配置说明\n\n- `job_name:\"dockerswarm\"`: docker swarm 节点监控\n\t- `dockerswarm_sd_configs`: 使用 `prometheus` 内置支持的 `dockerswarm` 服务发现配置\n\t\t- `host`: 配置 `unix:///var/run/docker.sock` 访问 docker 的守护进程\n\t\t- `role`: 配置为 `node` 用于访问表示监控 `docker swarm` 节点\n\t- `__meta_dockerswarm_node_address`: 使用 docker swarm 节点地址替换 `__address` label\n\t- `__meta_dockerswarm_node_hostname`: 使用 docker swarm hostname 替换 `instance` label\n- `job_name: 'dockertasks'`: docker task 监控, 监控容器\n\t- `dockerswarm_sd_configs`: 同样使用 docker swarm 服务发现配置\n\t\t- `host`: 配置 `unix:///var/run/docker.sock` 访问 docker 的守护进程\n\t\t- `role`: 配置为 `tasks` 用于访问表示监控 `docker swarm` 运行的容器\n\t- `__meta_dockerswarm_task_desired_state`: 过滤容器运行状态要保持容器状态微 `running`\n\t- `__meta_dockerswarm_container_label_com_docker_stack_namespace`: 容器运行的命名空间, 对应的是 docker swarm 中的 `stock` , `namespace` 是 `k8s` 中不同环境之间隔离的划分名称, 这里过滤掉 `stock` 非 `dev` \n\t- `__meta_dockerswarm_container_label_external_metrics_enable`: 过滤开启了监控的容器\n\t- `__address__`: 替换默认监控容器的端口, 我习惯上使用容器内的 `8080` 端口作为服务的默认访问端口, 可以根据跟人习惯修改\n\t- `__meta_dockerswarm_service_label_com_docker_stack_namespace`: 使用 `stack` 替换 `namespace`\n\t- `__meta_dockerswarm_service_name`: 使用`docker swarm`的服务名称替换掉 `application` 和 `serviceName` label\n\t- `__meta_dockerswarm_task_id`: 使用 `task_id` 替换掉 `instance`\n\n## docker_compose.yml 配置\n\n```yaml\nversion: \"3.5\"\n\nservices:\n  prometheus:\n    image: prom/prometheus:latest\n    ports:\n      - \"9090:9090\"\n    user: root\n    deploy:\n      mode: replicated\n      replicas: 1\n      placement:\n        constraints:\n          - node.role == manager\n    networks:\n      - overlay\n    configs:\n      - source: prometheus_config\n        target: /etc/prometheus/prometheus.yml\n    command:\n      - '--config.file=/etc/prometheus/prometheus.yml'\n    volumes:\n      - /var/run/docker.sock:/var/run/docker.sock:ro\n\nconfigs:\n  prometheus_config:\n    file: ./prometheus.yml\n\nnetworks:\n  overlay:\n```\n\n- `user：root`: 使用 root 用户创建容器，因为需要监听 `docker.sock`\n- 挂载 `/var/run/docker.sock` 监控 docker swarm 集群情况\n- 挂载配置使用当前目录的配置文件创建 `docker config`\n- `- node.role == manager`: 将容器部署到 manager 节点\n- 加入到 overlay 网络\n\n## 在 docker swarm 集群部署\n\n在目标 stack 环境部署 prometheus\n\n```shell\n$ docker stack deploy -c docker_compose.yml {stack}\n```\n\n",
    "supporting": [
      "dockerswarm_files"
    ],
    "filters": [],
    "includes": {}
  }
}